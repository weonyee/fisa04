### 오늘 배운 것
1) 모듈
2) 예외처리
3) 클래스
4) 던더메소드

***

### 발견 discovery

#### 예외처리

1) 컴파일 에러

- 작성한 내용을 컴퓨터가 이해할 수 있게 변환하는 과정에서 나는 오류 

- 개발자가 해결할 수 있는 *syntax error* 같은 거

2) 런타임 에러

- 컴파일 성공 후 실행 중에 발생되는 에러

- 예) recursion 에러



***


### 배운점 learned

1) 예외 처리는 함수 밖에서 하는 게 좋음(메모리 이슈)

2) 클래스

    class Car():
        # 클래스 변수
        num = 0
        name = '정원중고차'

        # 인스턴스 변수 - self 명령어로 메모리 주소를 넘긴다
        def __init__(self):
            self.name = ''
            self.cc = 0
            self.color = ''
            self.num = Car.num
            Car.num += 1

        # 클래스 함수 - 클래스의 속성을 제어하기 위해 사용되는 함수
        @classmethod # @:데코레이터
        def print_final_num(cls): # cls를 통해서 class의 메모리 주소가 전달된다.
            print(f'{cls.num}대의 차량 정보가 있습니다.')

        # 인스턴스 함수(메서드) - self 명령어로 메모리 주소를 넘긴다
        def start(self):
            print(f'{self.name} 차량이 출발합니다.~')


2-2) 변수

- 인스턴스 변수 : 인스턴스 자체에만 해당되는 정보

    - 객체 간 서로 변수를 공유하지 않음

- 클래스 변수 : 클래스에서 종합해서 관리해야 하는 정보

    - 객체와 무관한 변수(객체 없이도 참조 가능한 함수)


***

### 선언 declaration

**EAFP(It's Easier Ask Forgiveness than Permission**

- 허락보다 용서가 쉽다. 일단 실행하고 예외가 발생하면 그때 처리해라. 

- 얕은 복사 깊은 복사는 늘 헷갈리지 않게 ..


***

### 자습 self study

#### 오버라이딩

**상속**을 기반으로 한 객체지향프로그래밍의 중요 개념

자식 클래스에서 부모 클래스의 메서드를 재정의하는 기능

- 같은 이름/매개변수를 가진 메서드를 정의하면 덮어쓰기 됨

- 좀 더 구체적이고 세부적인 동작을 정의할 수 있음


+) 자식 클래스에서 부모 클래스 메서드를 호출하려면 **super()**


#### 다형성(polymorphism)

= 여러 형태를 가질 수 있는 능력

1) **종류**

- 메서드 오버라이딩 : 재정의

- 메서드 오버로딩 : 매개변수 수나 타입을 다르게 하여 정의

- 연산자 오버로딩 : 기본 연산자의 동작 방식을 변경하는 것



2) **특징**

- 상속과 오버라이딩을 통해 구현 가능

- 하나의 메서드로 여러 타입의 객체를 처리 가능

- 코드를 더 유연하게, 재사용 가능하게 만듦
