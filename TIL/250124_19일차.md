


### 오늘 한 것

#### Docker

- dockerfile & docker image 생성
- container 설계
- container간 network 통신
- docker compose

  
***


### 발견 discovery

#### 기억하면 좋을 점

**명확한 레이어 캐싱 전략**

- 되도록 수정사항은 뒤쪽에
- 자주 변경되지 않는 항목을 먼저 실행하여 캐시를 최대한 활용

**multi-stage builds**

- 빌드와 실행환경 분리
- 최종 이미지 최소화

      RUN pip install numpy
      RUN pip install pandas
  
      
      RUN pip install numpy pandas

  
#### 컨테이너 생성 시 고려할 점

1. 1 컨테이너 1 프로세스

2. 변경 불가능한 인프라 원칙 준수

- 관리 - 버전 태그 사용
    - 이미지 빌드마다 고유한 버전 태그를 사용하여 이미지 변경을 명확히 함
 
- 검증
    - 새 이미지가 프로덕션 환경에 배포되기 전에 테스트 환경에서 충분히 검증
    - 개발용 환경과 배포용 환경을 구분해서 작업
 
- 빌드와 배포
    - 컨테이너 실행 중에는 컨테이너 내부에서 변경 작업 불가
    - 변경이 필요한 경우 새로운 이미지를 빌드
    - 배포 이력을 관리하는 방법 -> 컨테이너 이미지를 중간에서 변경 불가능하게 만들어 일관된 배포 환경 보장

3. 경량 도커 이미지로 생성

- 불러오는 데도 시간이 줄어듦
- 불필요한 패키지, 라이브러리 제거 -> 이미지 크기 최소화 -> 보안, 성능 향상
- 배포 시간과 리소스 사용 줄이는 데에 도움이 됨

4. 실행 계정은 비root 사용자
- 보안: 컨테이너 내부의 프로세스는 root 권한 X
  - 일반 사용자 권한으로 부여 -> 잠재적 보안 취약점 줄이고, 시스템 전체에 대한 영향을 최소화


#### run vs cmd

- 같은 실행 명령어

**run** build과정에서 실행

**cmd** build한 컨테이너가 동작할 때 실행


***


### 배운점 learned

#### docker hub

- docker에서 운영하는 공식 registry
- docker image 배포 시스템이자 원격 저장소
- 주의할 점: DB 접속 주소, 돈이 나가는 컨텐츠 등을 공개하지 않도록 public으로 이용할 때는 조심


#### docker file

- 코드의 형식으로 인프라를 구성하여 docker 이미지 파일을 생성할 수 있는 텍스트 파일
- 사용할 이미지나 실행할 특정 명령어로 구성

      # 원본 이미지명
      # 순서대로 dockerfile을 읽으면서 캐시랑 다른 내용부터 재시작
      # 자주 변경되는 작업은 뒤쪽에 작성하면 read 속도가 빨라짐
      FROM nginx:latest
      
      # 실행할 명령구
      COPY . /usr/share/nginx/html/
      
      RUN echo "작업 완료" 


#### 컨테이너 설계

- 한번에 묶어서 하나의 덩어리로 관리 -> 결합도가 높아 이 중 하나에 에러가 나면 전체를 다 고쳐야 함
- **각각 나눠서 3개의 덩어리로 관리**

**생성 시 고려할 점**

- 1 컨테이너 1 프로세스
    - 단일 책임 원칙 준수 -> 유지 보수 및 스케일링 단순화
    - FE가 잘못되면 그것만 껐다 켜면 됨
 
- 변경 불가능한 인프라 원칙 준수(immutable infrastructure)

    - 관리 - 버전 태그 사용
    - 검증
    - 빌드와 배포

- 경량 docker image 생성

- 실행 계정은 비root 사용자


      # 컨테이너 안에서의 노출 : 도커파일의 명령어라고 생각
      EXPOSE 82 
      
      # 서비스에게 주는 명령어
      # 띄어쓰기 단위로 실행됨
      # nginx -g daemon off; 이런 식으로 join됨
      CMD ['nginx', '-g', 'daemon off;']
      
      # CMD 말고 다른 방법
      RUN nginx -g "daemon off;"
      
      # run과 cmd는 같은 명령어
      # cmd에 띄어쓰기 단위로 값을 전달해서 실행하는 것이 권장됨

***

### 선언 declaration

연휴에 SQL 문제 풀어보기, docker 개념 이해 위한 강의 듣기 !!


***

### 자습 Self study

#### 정처기 4과목

**SSTF = shortest seek time first**

현재 헤드 위치에서 가장 가까운 것부터

**A,B,C class**

A class에 속하는 ip 주소 범위: 0.0.0.0 ~ 127.255.255.255
B class에 속하는 ip 주소 범위: 128.0.0.0 ~ 191.255.255.255
C class에 속하는 ip 주소 범위: 192.0.0.0 ~ 223.255.255.255

D class와 E class는 각각 멀티캐스트용, 연구용으로 사용됩니다.
D class에 속하는 ip 주소 범위: 224.0.0.0 ~ 239.255.255.255
E class에 속하는 ip 주소 범위: 240.0.0.0 ~ 255.255.255.255

**프로세스**

- 프로세스가 준비 상태에서 배당되어 실행 상태로 변화하는 것 **디스패치**
- 프로세스 제어 블록(PCB, process control block): 프로세스 식별자, 프로세스 상태 등의 정보로 구성
- 이전 프로세스의 상태 레지스터 내용을 보관하고 다른 프로세스의 레지스터를 적재하는 과정 **문맥 교환**

**모듈의 독립성을 높이기 위한 결합도**

- 오류가 발생했을 때 전파되어 다른 오류의 원인이 되는 파문효과를 최소화해야 함
- 인터페이스가 정확히 설정되어 있지 않을 경우 불필요한 인터페이스가 나타나 모듈 사이의 의존도가 높아지고 결합도가 증가
- 다른 모듈과 데이터 교류가 필요한 경우 전역변수보다는 매개변수를 사용하는 것이 결합도를 낮추는데 도움이 됨
- 모듈들이 변수를 공유하여 사용하게 하거나 제어 정보를 교류하게 하면 모듈 간의 결합도가 높아짐

**TCP 헤더**

- 순서번호는 전달하는 바이트마다 번호가 부여된다.
- 수신번호확인은 상대편 호스트에서 받으려는 바이트의 번호를 정의
- 체크섬은 데이터를 포함한 세그먼트의 오류를 검사
- window size : 16비트 2^16 = 64kb

**페이지 교체 알고리즘**

- OPT: optimal : 앞으로 가장 오랫동안 사용되지 않을 페이지 교체
- FIFO: First in First out
- LRU: least recently used : 가장 오랫동안 사용되지 않은 페이지 교체
- LFU: least frequently used : 참조 횟수가 가장 적은 페이지 교체
- MFU: most frequently used: 참조 횟수가 가장 많은 페이지 교체
- NUF: Not used recently: 최근에 사용하지 않은 페이지 교체

**파일 디스크립터**

- 파일 관리를 위해 시스템이 필요로 하는 정보를 가지고 있음
- 보조기억장치에 저장되어 있다가 파일이 개방되면 주기억장치로 이동
- 파일 제어 블록이라고도 함
- 파일마다 따로 있으며 시스템에 따라 다른 구조를 가질 수 있음
- 파일 시스템에서 관리하므로 사용자가 직접 참조할 수 없다
- 파일의 이름, 위치, 구조, 보조기억장치 유형, 파일의 유형, 시간, 액세스 등의 정보를 담고 있음
