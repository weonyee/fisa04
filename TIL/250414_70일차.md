## AWS

***

## 1. Autoscaling

> **시스템의 부하**에 따라 **서버의 수를 자동으로 조절**하는 기능
> 
- 두 가지 종류가 있음
    - EC2(VM) 기반
    - 컨테이너 기반(ECS/EKS)
- 온프레미스는 MAX USER 기준으로 구축
    - 예. 쇼핑몰 2-5시 제일 한가함
        - VM 10개, 평균 CPU가 50% 이상 차면 VM을 늘려라
- 트래픽 추세를 따라 리소스 사용하는 Autoscaling이 보편적으로 사용됨

**오토스케일링 필요한 이유**

- 트래픽이 급증할 때
    - 갑자기 사용자가 많아지면 서버가 버벅일 수 있음
    - 오토스케일링이 자동으로 서버 늘려서 대응
- 비용 절감
    - 사용자가 적을 땐 서버 줄여서 불필요한 리소스 줄이고 비용 줄여줌
- 24시간 감시 필요 없음
    - 개발자가 서버 상태를 실시간으로 체킹하지 않아도 됨 → 운영 부담 감소

**작동 기준**

- CPU 사용률
- 메모리 사용량
- 네트워크 트래픽

**ELB**

- AWS에는 3가지 종류의 로드 밸런서 존재
- 온프레미스와 연동하기 위한 CLB(클래식로드밸런서)가 있음

**오토스케일링 순서**

1. 도메인 주소를 이용하고 싶은 경우 사전 작업
    - 도메인 등록(가비아) → Route53에서 세팅 → ACM에서 인증서 발금
2. AMI 생성
3. 대상그룹 만들기
4. ALB 만들기
5. 시작 템플릿 만들기
6. 오토스케일링 만들기

## 2. 로드밸런서

> 여러 서버에 트래픽을 골고루 나눠주는 배급기

- 사용자들이 웹사이트에 접속할 때, 로드밸런서가 “이 요청은 A한테~ 저 요청은 B한테~’ 분배함
- 서버에 부담이 몰리지 않도록 분산

**필요한 이유**

- 서버 과부하 방지
    - 한 서버에 요청이 몰리면 터질 수도 있는데 로드밸런서가 분산시켜줌
- 트래픽 분산 = 빠른 응답 속도
    - 트래픽이 분산되면 사용자들도 더 빠르게 서비스 이용 가능
- 장애 대응
    - 서버 하나가 다운되면, 로드밸런서가 해당 서버로 요청 안보냄
    - 살아있는 서버에만 요청을 보내서 서비스가 끊기지 않게 해줌

**분산 방식**

1. Round Robin 
    - 순서대로 돌아가면서 분배
    - A → B → C → A → …
2. Least Connections 
    - 현재 연결이 가장 적은 서버에 분배
3. IP Hash
    - 접속한 사람의 IP를 기반으로 항상 같은 서버에 연결되게

**로드밸런서 + 오토스케일링 = 찰떡궁합**

- 로드 밸런서는 여러 서버 간 분산
- 오토스케일링은 필요에 따라 서버 개수 조절

⇒ 같이 움직이면 **부하 분산 + 서버 자동 확장** 이라는 완벽한 인프라 관리 가능

## 3. 그래프 BFS DFS

### 그래프

- **노드**와 **간선**으로 이루어진 구조

### DFS(Depth-First Search, 깊이 우선 탐색)

- 한 갈래로 쭉 ~ 끝까지 갔다가 더 이상 못 가면 뒤로 돌아와서 다른 길로 가는 방식
- 깊이부터 파고들고, 막히면 돌아옴

**구현 방식** - 재귀함수 / 스택

**특징**

- 경로를 찾는 데 유리
- 백트래킹 문제에 많이 사용됨
    - 예. 미로, 퍼즐

```
# DFS (재귀)
def dfs(node, visited=set()):
    if node not in visited:
        print(node, end=' ')
        visited.add(node)
        for neighbor in graph[node]:
            dfs(neighbor, visited)
```

### BFS(Breadth-First Search, 너비 우선 탐색)

- 시작점에서 가까운 애들부터 싹 훑고, 그 다음 한 칸 멀리 있는 애들로 가는 방식
- 레벨별로 훑어나감

**구현 방식** - 큐(먼저 들어온 순서대로 나감

**특징**

- 최단 거리 찾기에 유리
- 그래프가 넓게 퍼진 구조에서 사용됨

```
# BFS
from collections import deque
def bfs(start):
    visited = set()
    queue = deque([start])
    while queue:
        node = queue.popleft()
        if node not in visited:
            print(node, end=' ')
            visited.add(node)
            queue.extend(graph[node])
```

### DFS vs BFS

|구분|DFS|BFS|
|---|---|---|
|방식|깊이 우선|너비 우선|
|자료구조|스택 or 재귀|큐|
|특징|경로 찾기, 백트래킹|최단 거리, 레벨 탐색|
|예|퍼즐, 미로|최단 거리 찾기, 네트워크 탐색|
